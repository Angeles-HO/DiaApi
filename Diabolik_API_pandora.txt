--[[ Tables ]]--
local client = {
    log = client.log,
    --[[ 
        - client.log(msg: string, color: color, prefix: string, visible: boolean).
        - msg	string	The message that will appear in the top left / console.
        - color	color	The message's color (white by default).
        - prefix	string	The message's prefix (empty by default).
        - visible	boolean	If defined as true (default) the message will show in the top left otherwise it will only appear in the console.
    ]]--
    load_script = client.load_script,
    --[[ 
        -file_name	string	The file to load by name (example: "some.lua")
    ]]--
    choked_commands = client.choked_commands,
    --[[ 
        - returns amount of currently choked commands.
        - client.choked_commands(): number (integer).
    ]]--
    is_alive = client.is_alive,
    --[[ 
        - returns whether the localplayer is alive or not.
        - client.is_alive(): boolean.
    ]]--
    latency = client.latency,
    --[[ 
        - returns latency (rtt) to server
        - client.latency(): string
    ]]--
    local_time = client.local_time,
    --[[ 
        - client.local_time(format: string): string
        - format	string	time formatting
        - client.local_time("%r") -- will get you localized time string (including seconds)
        - client.local_time("%I:%M:%S") -- will get you HH:MM:SS time string (12-hour-format)
        - client.local_time("%H:%M:%S") -- will get you HH:MM:SS time string (24-hour-format)
    ]]
    unix_timestamp = client.unix_timestamp,
    --[[ 
        - returns unix timestamp
        - client.unix_timestamp(): number (integer) 
    ]]
    map_name = client.map_name,
    --[[ 
        - returns map name if ingame
        - client.map_name(): string
    ]]
    camera_position = client.camera_position,
    --[[ 
        - returns position of camera
        - client.camera_position(): vector
    ]]
    camera_angles = client.camera_angles,
    --[[ 
        - returns camera angles
        - client.camera_angles(): qangle
    ]]
    find_sig = client.find_sig,
    --[[ 
        - returns address as integer or 0 when pattern (IDA-Style) was not found
        - client.find_sig(module: string, sig: string): number (integer)
        - Argument	   Type	       Description
        -  module	 string   	 e.g "client.dll"
        -   sig	    string    e.g "A3 ? ? ? ? 57 8B CB"
    ]]
    create_interface = client.create_interface,
    --[[ 
        - returns an address to the interface or 0 when not found
        - client.create_interface(module: string, interface: string): number (integer)
        - module	string	e.g "client.dll"
        - interface	string	e.g "VClient018" (has to be interface name (e.g. "VClient") including exact version (e.g. "018"))
    ]]
    username = client.username,
    --[[ 
        - global variable for the current user's name (displayed in watermark)
        - client.username 
    ]]
    -- eye_position = client.eye_position, not found
}

local anti_aim = {
    inverted = anti_aim.inverted,
    --[[ 
        - returns true when inverted or false when not
        - anti_aim.inverted(): boolean
    ]]
    should_run = anti_aim.should_run
    --[[ 
        - returns true when cheat should anti-aim on the command or false when not
        - anti_aim.should_run(cmd: usercmd, skip_firing_check: boolean): boolean
        - cmd	usercmd	-
        - skip_firing_check	boolean	when defined as true, the function will not account for firing (you ideally don't want to modify viewangles when firing)
    ]]
}

local engine_trace = {
    trace_ray = engine_trace.trace_ray,
    --[[ 
        - returns a game_trace object
        - engine_trace.trace_ray(start: vector, end: vector, skip: entity, mask: number): game_trace
        - start	vector	trace starting position
        - end	vector	trace ending position
        - skip	entity	entity to be skipped (filter)
        - mask	number (integer)	trace mask
    ]]
}

local entity = {
    hitbox_position = entity.hitbox_position,
}

local entity_list = {
    get_client_entity = entity_list.get_client_entity,
    --[[ 
        - returns an entity object
        - entity_list.get_client_entity(entnum: number OR netvar): entity
        - entnum	number (integer) OR netvar (handle by an existing entity)	reference to the entity.
    ]]
    get_all = entity_list.get_all,
    --[[ 
        - returns a table of all indices (valid entities) of the given entity/network name
        - entity_list.get_all(networkname: string): table (number -> entindex).
        - networkname	string	network name of the entity.
    ]]
    get_highest_entity_index = entity_list.get_highest_entity_index
    --[[ 
        - returns the index of the entity with the highest index
        - entity_list.get_highest_entity_index(): number
    ]]
}

local engine = {
    get_player_for_user_id = engine.get_player_for_user_id,
    --[[ 
        - returns an entity index (used for converting userid's of game events to entity indices)
        - engine.get_player_for_user_id(userid: number): number (integer)
        - userid	number (integer)	user id
    ]]
    in_game = engine.in_game,
    --[[ 
        - returns true if you are in a game or false if not
        - engine.in_game(): boolean
    ]]
    is_connected = engine.is_connected,
    --[[ 
        - returns true if you are connected to a server or false if notâ€Œ
        - engine.is_connected(): boolean
    ]]
    execute_client_cmd = engine.execute_client_cmd,
    --[[ 
        - executes a console command
        - engine.execute_client_cmd(cmd: string)
        - cmd	string	the commands name
    ]]
    set_view_angles = engine.set_view_angles,
    --[[ 
        - sets the engine view angles
        - engine.set_view_angles(viewangle: qangle)
        - viewangle	qangle	the viewangles to be set
    ]]
    get_view_angles = engine.get_view_angles,
    --[[ 
        - returns the engine view angles as a qangle object
        - engine.get_view_angles(): qangle
    ]]
    get_local_player = engine.get_local_player,
    --[[ 
        - returns the entity index of the local player
        - engine.get_local_player(): number
    ]]
    get_player_info = engine.get_player_info
    --[[ 
        - returns a player_info object
        - engine.get_player_info(entnum: number): player_info
        - entnum	number (integer)	an entity's index
    ]]
}

local esp = {
    set_thirdperson_animation = esp.set_thirdperson_animation,
    --[[ 
        - enable / disable thirdperson animation
        - esp.set_thirdperson_animation(value: boolean)
        - value	boolean	state (true by default)
    ]]
    set_fading_chams = esp.set_fading_chams,
    --[[ 
        - enable / disable chams animation
        - esp.set_fading_chams(value: boolean)
        - value	boolean	state (true by default)
    ]]
    add_player_flag = esp.add_player_flag
    --[[ 
        - adds a flag to the esp (right side of the box) NOTE: should be called inside paint callback
        - esp.add_player_flag(flag: string, color: color, entindex: number)
        - flag	string	the text to display
        - color	color	color of the text
        - entindex	number (integer)	the index of the player this flag should be displayed on
    ]]
}

local penetration = {
    damage =  penetration.damage,
    --[[ 
        - returns penetration damage of first penetrated wall
        - penetration.damage(): number (integer)
    ]]
    simulate_bullet = penetration.simulate_bullet
    --[[ 
        - simulates a bullet and returns damage, penetration count (amount of penetrations), hitgroup (the hitgroup that was hit)
        - penetration.simulate_bullet(attacker: entity, start: vector, end: vector): number (integer), number (integer), number (integer)
        - attacker	entity	the desired attacker (the data will be based on this entity)
        - start	vector	starting position
        - end	vector	ending position
    ]]
}

local material = {
    create_material = function() return material.create_material end,
    --[[ 
        - returns a material, make sure to check whether it is valid
        - materials.create_material(name: string, vmt: string, type: string): material
        - name	string	the materials name (can be found using materials.find_material)
    ]]
    find_material = function() return material.find_material end,
    --[[ 
        - returns a material, make sure to check whether it is valid
        - materials.find_material(name: string, group: string): material
        - name	string	the materials name
        - group	string	!OPTIONAL! the materials texture group
    ]]
}

local commands = {
    in_attack = function() return commands.in_attack end, -- attack
    in_jump = function() return command.in_jump end, -- jump
    in_duck = function() return command.in_duck end, -- duck
    in_forward = function() return command.in_forward end, -- forward
    in_back = function() return command.in_back end, -- back
    in_use = function() return command.in_use end, -- use
    in_cancel = function() return command.in_cancel end, -- cancel
    in_left = function() return command.in_left end, -- left
    in_right = function() return command.in_right end, -- right
    in_moveleft = function() return command.in_moveleft end, -- move moveleft
    in_moveright = function() return command.in_moveleft end, -- move moveright
    in_attack2 = function() return command.in_attack2 end, -- attack2
    in_reload = function() return command.in_reload end, -- reload
    in_speed = function() return command.in_speed end, -- speed
    in_bullrush = function() return command.in_bullrush end -- bull bullrush
}

local input = {
    key_down = input.key_down,
    --[[ 
        - returns true if the key is currently being held or false if not
        - input.key_down(key: number): boolean
        - key	number (integer)	virtual key code
    ]]
    key_pressed = input.key_pressed,
    --[[ 
        - returns true if the key was pressed (key was pressed and is still being held down) or false if not
        - input.key_pressed(key: number): boolean
        - key	number (integer)	virtual key code
    ]]
    mouse_position = input.mouse_position,
    --[[ 
        - returns x and y coordinate of mouse position
        - input.mouse_position(): number, number
    ]]
    force_cursor = input.force_cursor
    --[[ 
        - force enable / disable cursor(and input)
        - input.force_cursor(state: boolean)
        - state	boolean	enabled/disabled (true/false)
    ]]
}

local exploits = {
    process_ticks = exploits.process_ticks,
    --[[ 
        - returns current amount of process ticks
        - exploits.process_ticks(): number (integer)
    ]]
    max_process_ticks = exploits.max_process_ticks,
    --[[ 
        - returns maximum amount of process ticks
        - exploits.max_process_ticks(): number (integer)
    ]]
    charging = exploits.charging,
    --[[ 
        - returns true if you are currently charging process ticks
        - exploits.charging(): boolean
    ]]
    ready = function() return exploit.ready end,
    --[[ 
        - returns true if exploits are ready
        - exploits.ready(): boolean
    ]]
    force_recharge = exploits.force_recharge,
    --[[ 
        - forces exploits to be recharged
        - exploits.force_recharge() 
    ]]
}

local ui = {
    is_open = ui.is_open,
    --[[ 
        - returns true if the ui is currently open or false when it is closed
        - ui.is_open(): boolean
    ]]
    get = ui.get,
    --[[ 
        - gets a reference to a menu item and returns specified item as object
        - supported tabs: Rage (Aimbot)
        - ui.get(tab: string, sub_tab: string, group: string, option: string, weapon_group: string): UI
    ]]
    get_rage = ui.get_rage,
    --[[ 
        - gets a reference to a menu item and returns specified item as object (for active weapon configuration)
        - NOTE: should be called inside a paint or post_move callback, as otherwise you will receive the object of the weapon configuration that was active at the time of loading the script
        - supported tabs:
        - Rage (Aimbot)
        - ui.get_rage(group: string, option: string): UI
    ]]
    add_checkbox = ui.add_checkbox,
    --[[ 
        - adds a Checkbox to the "Items" group box of the LUA tab (script specific) and returns a checkbox object
        - ui.add_checkbox(name: string): checkbox
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
    ]]
    add_dropdown = ui.add_dropdown,
    --[[ 
        - adds a Dropdown to the "Items" group box of the LUA tab (script specific) and returns a dropdown object
        - ui.add_dropdown(name: string, [items: string]): dropdown
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - items	string table	items (names)
    ]]
    add_multi_dropdown = ui.add_multi_dropdown,
    --[[ 
        - adds a Multi-dropdown to the "Items" group box of the LUA tab (script specific) and returns a multidropdown object
        - ui.add_multi_dropdown(name: string, [items: string]): multidropdown
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - items	string table	items (names)
    ]]
    add_button = ui.add_button,
    --[[ 
        - adds a button to the "Items" group box of the LUA tab (script specific) and returns a button object
        - ui.add_button(text: string): button
        - text	string	displayed text
        [Example]
        local button = ui.add_button("My epic button")
        button:add_callback(function()
            print("test!") -- will print text to the game's console
        end)
    ]]
    add_textbox = ui.add_textbox,
    --[[ 
        - adds a textbox to the "Items" group box of the LUA tab (script specific) and returns a textbox object
        - ui.add_textbox(name: string): textbox
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        -returns the textbox input vale as a string
        -textbox_object:get(): string
    ]]
    add_label = ui.add_label,
    --[[ 
        - adds a label (text) to the "Items" group box of the LUA tab (script specific)
        - ui.add_label(text: string)
        - text	string	displayed text
    ]]
    add_cog = ui.add_cog,
    --[[ 
        - set_key_cond |0 = hold | 1 = toggle | 2 = always|
        - adds a Cog (without label, ..) to the "Items" group box of the LUA tab (script specific) and returns a cog object
        - ui.add_cog(tooltip: string, color: boolean, hotkey: boolean): cog
        - tooltip	string	Tooltip (this should be unique in-script as it is used for the configuration system -> avoid adding 2 or more items with the same Tooltip)
        - color	boolean	when true, a colorpicker will be added
        - hotkey	boolean	when true, a hotkey will be added
        [example]
        -- you have to add a label, checkbox, .... before the cog
        -- as the cog is relative to previous items and may not show otherwise.
        ui.add_label("My epic cog") -- this does not return anything
        local cog_item = ui.cog("My Epic Tooltip", true, true)
    ]]
    add_slider = ui.add_slider,
    --[[ 
        - adds a Slider to the "Items" group box of the LUA tab (script specific) and returns a slider object
        - ui.add_slider(name: string, min: number, max: number): slider
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - min	number (integer)	minimum value of the slider
        - max	number (integer)	maximum value of the slider
        [example]
        local slider_item = ui.add_slider("My epic slider", 0, 1337)
    ]]
    add_slider_float = ui.add_slider_float,
    --[[ 
        - adds a Slider to the "Items" group box of the LUA tab (script specific) and returns a slider object
        - ui.add_slider_float(name: string, min: number, max: number): slider
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - min	number (float)	minimum value of the slider
        - max	number (float)	maximum value of the slider
        [example]
        local slider_item = ui.add_slider_float("My epic slider", 0.1, 69.69)
    ]]
}

local cvar = {
    find_var = cvar.find_var
    --[[ 
        - returns a convar object
        - cvar.find_var(var_name: string): convar
        - var_name	string	console command's name
    ]]
}

local render = {
    rectangle = render.rectangle,
    --[[ 
        - draws a rectangle
        - render.rectangle(x: number, y: number, w: number, h: number, color: color)
        - x	number (integer)	x coordinate
        - y	number (integer)	y coordinate
        - w	number (integer)	render width
        - h	number (integer)	render height
        - color	color	color the drawing renders with
    ]]
    rectangle_filled = render.rectangle_filled,
    --[[ 
        - draws a filled rectangle
        - render.rectangle_filled(x: number, y: number, w: number, h: number, color: color)
    ]]
    gradient = render.gradient,
    --[[ 
        - draws a filled fade rectangle
        - render.gradient(x: number, y: number, w: number, h: number, color: color, color2: color, horizontal: boolean)
        - [Extra]
        - color	color	color of the first half the drawing renders with
        - color2	color	color of the second half the drawing renders with
        - horizontal	boolean	fading direction (vertical by default)
    ]]
    triangle_filled = render.triangle_filled,
    --[[ 
        - render.triangle_filled(pos1: vector2d, pos2: vector2d, pos3: vector2d, color: color)
        - pos1	vector2d	coordinate of first corner
        - pos2	vector2d	coordinate of second corner
        - pos3	vector2d	coordinate of third corner
        - color	color	color the drawing renders with
    ]]
    circle_world = render.circle_world,
    --[[ 
        - draws a (filled) circle in world space (no world to screen required)
        - render.circle_world(origin: vector, radius: number, color: color, colorFill: color)
        - origin	vector	the circles origin/position in world space
        - radius	number (float)	the circles radius
        - color	color	color the drawing renders with (outer circle, "outline")
        - colorFill	color	color the drawing renders with (inner circle, "filling")
    ]]
    circle_filled = render.circle_filled,
    --[[ 
        - draws a filled circle
        - render.circle_filled(x: number, y: number, radius: number, segments: number, color: color)
        - x	number (integer)	x coordinate
        - y	number (integer)	y coordinate
        - radius	number (float)	circle radius
        - segments	number (integer)	circle segments
        - color	color	color the drawing renders with
    ]]
    line = render.line,
    --[[ 
        - draws a line
        - render.line(x: number, y: number, x2: number, y2: number, color: color)
        - x	number (integer)	(from) x coordinate
        - y	number (integer)	(from) y coordinate
        - x2	number (integer)	(to) x coordinate
        - y2	number (integer)	(to) y coordinate
        - color	color	color the drawing renders with
    ]]
    text = render.text,
    --[[ 
        draws a text
        render.text(x: number, y: number, text: string, color: color)
        x	number (integer)	x coordinate
        y	number (integer)	y coordinate
        text	string	text to draw
        color	color	color the drawing renders with
    ]]
    get_text_size = render.get_text_size,
    --[[ 
        - returns width and height of the text given (font used in render.text)
        - render.get_text_size(text: string): number, number
        - text	string	text you want to get the width/height of
    ]]
    create_font = render.create_font,
    --[[ 
        - returns a Font object (avoid calling this in a callback function, setup before doing anything)
        - render.create_font(fontname: string, size: number, weight: number, flags: font_flags): Font
        - fontname	string	font name (Arial, ...)
        - size	number (integer)	font size in pixels
        - weight	number (integer)	font weight
        - flags	font_flags	font flags
    ]]
    get_screen = render.get_screen,
    --[[ 
        - returns the width and height of the screen
        - render.get_screen(): number, numbe
    ]]
    world_to_screen = render.world_to_screen
    --[[ 
        - transforms the coordinates from world space to screen and returns true when successfully transformed or false when not
        - render.world_to_screen(input: vector, output: vector2d): boolean
        - input	vector	-
        - output	vector2d	output (screen coordinates)
    ]]
}

local font_flags = {
    font_flags = font_flags.none,
    --[[ 
        - no font flag
    ]]
    antialias = font_flags.antialias,
    --[[ 
        - adds anti-aliasing to the font
    ]]
    dropshadow = font_flags.dropshadow,
    --[[ 
        - adds a dropshadow to the font
    ]]
    outline = font_flags.outline,
    --[[ 
        - adds an outline to the font
    ]]
    --[[ 
        [Example]
        -- multiple flags example
        local arial_drop_outline = render.create_font("Arial", 12, 500, bit.bor(font_flags.dropshadow, font_flags.outline))
        -- single flag example
        local arial_drop = render.create_font("Arial", 12, 500, font_flags.dropshadow)
    ]]
}

local callbacks = {
    register = callbacks.register,
    deregister = callbacks.deregister
    --[[ 
        [paint]
        - used for drawing (or calling something) every frame (using the render functions).
        function on_paint()
            -- cool, useless, rectangle!
            render.rectangle(10, 10, 10, 10, color.new(255, 255, 255))
        end
        callbacks.register("paint", on_paint)

        [pre_frame_stage]
        - called right before FrameStageNotify and internal functions when localplayer is valid.
        function on_frame_stage(stage) -- stage: current frame stage
            
        end
        callbacks.register("pre_frame_stage", on_frame_stage)

        [post_frame_stage]
        - called right after FrameStageNotify and internal functions when localplayer is valid.
        function on_frame_stage(stage) -- stage: current frame stage

        end
        callbacks.register("post_frame_stage", on_frame_stage)
    
        [post_move]
        - used to modify the user command after the internal modifications using "usercmd".
        function on_post_move(cmd) -- the first argument is the command's "pointer"
            -- let's see if we want to anti aim
            if anti_aim.should_run(cmd, false) == false then    
                return
            end
        
            -- up pitch (gamer moment)
            cmd.viewangles.x = -89
        end

        callbacks.register("post_move", on_post_move)

        [predicted_move]
        - used to modify the user command inside prediction, after move related features have ran, using usercmd.
        function on_predicted_move(cmd) -- the first argument is the command's "pointer"
            -- do something
        end

        callbacks.register("predicted_move", on_predicted_move)

        [post_anim_update]
        - can be used to modify animation / bones related data of the local player.
        - set_float_index is undocumented, however it can be used to modify float arrays (like m_flPoseParameter)
        -- there also is get_float_index(index: number(integer)): number (float)
        -- "falling legs" example:
        callbacks.register("post_anim_update", function(ent)
            local m_flPoseParameter = ent:get_prop("DT_BaseAnimating", "m_flPoseParameter");
            m_flPoseParameter:set_float_index(6, 1); -- first argument is the index, second the value to be set to
        end)

        [on_hitmarker]
        - used to get the damage and position of where the localplayer hit.
        function on_hitmarker(damage, position) -- damage: number (float), position: vector

        end

        callbacks.register("on_hitmarker", on_hitmarker)

        [draw_model]
        - used to draw models using model_draw_context.
        -- grab a material (or create one)

        local flat_mat = materials.find_material("debug/debugdrawflat")
        -- let's see, if the material is valid
        local flat_mat_valid = flat_mat:is_valid()
        function on_draw_model(context) -- the first argument is the entity's model_draw_context
            -- let's see if the current entity is the localplayer
           if context:get_entity():index() == engine.get_local_player() then
                if flat_mat_valid then
                    -- r, g, b (0.0-1.0)
                    flat_mat:modulate_color(1, 1, 1)
                
                    -- a (0.0-1.0)
                    flat_mat:modulate_alpha(0.5)
                
                    -- set flag (ignorez)
                    flat_mat:set_material_var_flag((1 << 15), true) -- ignorez
                
                    -- draw the entity with our material
                    context:force_material_override(flat_mat)
                end
           end
        end

        callbacks.register("draw_model", on_draw_model)
    ]]
}

local vector = {
    new = vector.new
    --[[ 
        new (constructor)
        - vector.new(x: number, y: number, z: number)
        - 
        - Argument	Type	Description
        - x	number (float)	x value
        - y	number (float)	y value
        - z	number (float)	z value
    ]]
}

local vertex = {
    vertex = vertex.new,
    --[[ 
        - [Objet]
            vector2d	position
            vector2d	texCoord

        - vertex.new(position: vector2d, texCoord: vector2d)
        - Argument	Type	Description
        - position	vector2d	position
        - texCoord	vector2d	texture coordinate
        - local some_vertex = vertex.new(vector2d.new(69, 420), vector2d.new(1337, 0))
    ]]
}

local vector2d = {
    new = vector2d.new
}

local Qangle = {}
Qangle.__index = qangle.new

local color = {
    new = color.new
}

local bit = {
    band = bit.band,
    lshift = bit.lshift,
    bor = bit.bor
}

local urls = {
    fonts = "https://github.com/HeistOmega/DiaApi/raw/45c709dfce8fa8aa44d8cc27aa65541b86535023/fonts",
    sounds = "https://github.com/HeistOmega/DiaApi/raw/50293b198188bfcf7178ccb60b9c18524ef1ff47/Sounds",
    destination = {
        fonts = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\Diabolik\\fonts\\",
        sounds = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\Diabolik\\Sounds\\"
    }
}

local global_vars = {
    curtime = function() return global_vars.curtime end,
    --[[ 
        - global variable for the engines current time
        - global_vars.curtime: number (float)
    ]]
    frametime = function() return global_vars.frametime end,
    --[[ 
        - global variable for the engines frame time
        - global_vars.frametime: number (float)
    ]]
    absoluteframetime = function() return global_vars.absoluteframetime end,
    --[[ 
        - global variable for the engines absolute frame time
        - global_vars.absoluteframetime: number (float)
    ]]
    framecount = function() return global_vars.framecount end,
    --[[ 
        - global variable for the engines frame count
        - global_vars.framecount: number (integer) 
    ]]
    tickcount = function() return global_vars.tickcount end,
    --[[ 
        - global_vars.tickcount
        - global variable for the engines tick count
        - global_vars.tickcount: number (integer)
    ]]
    realtime = function() return global_vars.realtime end,
    --[[ 
        - global variable for the engines real time
        - global_vars.realtime: number (float)
    ]]
    max_clients = function() return global_vars.max_clients end,
    --[[ 
        - global variable for the engines max clients
        - global_vars.max_clients: number (integer)
    ]]
    interval_per_tick = function() return global_vars.interval_per_tick end
    --[[ 
        - global variable for the engines interval per tick
        - global_vars.interval_per_tick: number (integer)
    ]]
}

--[[ Update Important netvars ]]
local update_global_vars = function()
    global_vars.tickcount = global_vars.tickcount
    global_vars.curtime = global_vars.curtime
    global_vars.frametime = global_vars.frametime
    material.create_material = material.create_material
end

callbacks.register("paint", function()
    update_global_vars()
end)

--[[ Locals ]]
local base_path = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\"

--[[ FFI ]]
local ffi = require("ffi")
local urlmon = ffi.load('urlmon')
local kernel32 = ffi.load('kernel32')

ffi.cdef[[
    typedef int HRESULT;
    HRESULT URLDownloadToFileA(void* pCaller, const char* szURL, const char* szFileName, unsigned long dwReserved, void* lpfnCB);
    bool CreateDirectoryA(const char* lpPathName, void* lpSecurityAttributes);
]]

Create_directory = function(path)
    local result = kernel32.CreateDirectoryA(base_path .. path, nil)
    if result == 0 then
        local error_code = ffi.C.GetLastError()
        if error_code ~= 183 then  -- 183 significa que el directorio ya existe
            print("Error al crear el directorio. Codigo de error: " .. error_code)
            return false
        end
    end
    print("Directorio creado: \n" .. base_path .. path)
    return true
end

Download_file = function(url, destination)
    local result = urlmon.URLDownloadToFileA(nil, url, destination, 0, nil)
    if result == 0 then
        print("Descarga exitosa: \n" .. destination)
    else
        print("Error en la descarga. Codigo de error: " .. result)
    end
end

Download_files = function(file_list, base_url, base_destination)
    for _, file_name in ipairs(file_list) do
        local url = base_url .. "/" .. file_name
        local destination = base_destination .. file_name
        Download_file(url, destination)
    end
end

Get_team = function(entity) -- get health of entity
    local team_num = entity:get_prop("DT_BaseEntity", "m_iTeamNum"):get_int()
    return team_num
end

Get_health = function(entity) -- get health of entity
    local health = entity:get_prop("DT_BasePlayer", "m_iHealth"):get_int()
    return health
end

Is_alive = function(entity) -- returns true if the entity is alive
    if entity then
        local health = Get_health(entity)
        if health > 0 then
            return true
        else
            return false
        end
    end
end

Get_velocity = function(entity)
    -- Get the velocity vector magnitude of the entity
    if entity then
        local x = entity:get_prop("DT_BasePlayer", "m_vecVelocity[0]"):get_float()
        local y = entity:get_prop("DT_BasePlayer", "m_vecVelocity[1]"):get_float()
        return math.floor(math.sqrt(x * x + y * y))
    end
    return 0
end

Is_crouching = function(entity)
    -- Check if the entity is crouching
    if entity then
        local flags = entity:get_prop("DT_BasePlayer", "m_fFlags"):get_int()
        return bit.band(flags, bit.lshift(2, 0)) ~= 0
    end
    return false
end

Is_inair = function(entity)
    -- Check if the entity is in the air
    if entity then
        return entity:get_prop("DT_BasePlayer", "m_hGroundEntity"):get_int() == -1
    end
    return false
end

Is_moving = function(entity)
    -- Check if the entity is moving, but not in the air
    if entity then
        local velocity = Get_velocity(entity)
        return velocity > 49 and not Is_inair(entity)
    end
    return false
end

Is_standing = function(entity)
    -- Check if the entity is standing (not moving and not in the air)
    if entity then
        return not Is_moving(entity) and not Is_inair(entity)
    end
    return false
end

Is_slow_walking = function(entity)
    -- Check if the entity is using slow walk
    return entity and ui.get_rage("Misc", "General", "Movement", "Slow motion key"):get_key()
end

Is_fake_ducking = function(entity)
    -- Check if the entity is fake-ducking (not in air, with specific duck speed/amount)
    if entity then
        local duck_speed = entity:get_prop("DT_BasePlayer", "m_flDuckSpeed"):get_float()
        local duck_amount = entity:get_prop("DT_BasePlayer", "m_flDuckAmount"):get_float()
        return duck_speed == 8 and duck_amount > 0 and not Is_inair(entity)
    end
    return false
end

return {
    client = client,
    anti_aim = anti_aim ,
    engine_trace = engine_trace,
    entity = entity,
    entity_list = entity_list,
    engine = engine,
    esp = esp,
    penetration = penetration,
    material = material,
    commands = commands,
    input = input,
    exploits = exploits,
    ui = ui,
    cvar = cvar,
    font_flags = font_flags,
    render = render,
    callbacks = callbacks,
    vector = vector,
    vector2d = vector2d,
    vertex = vertex,
    Qangle = Qangle,
    color = color,
    bit = bit,
    global_vars = global_vars,
    urls = urls,
    Get_velocity = Get_velocity,
    Is_crouching = Is_crouching,
    Get_health = Get_health,
    Is_alive = Is_alive,
    Get_team = Get_team,
    Is_inair = Is_inair,
    Is_moving = Is_moving,
    Is_standing = Is_standing,
    Is_slow_walking = Is_slow_walking,
    Is_fake_ducking = Is_fake_ducking,
    Create_directory = Create_directory,
    Download_files = Download_files,
}
