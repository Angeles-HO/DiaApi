---@diagnostic disable: undefined-global
--[[ Tables ]]--
local client = {
    log = client.log,
    --[[ 
        - client.log(msg: string, color: color, prefix: string, visible: boolean).
        - msg	string	The message that will appear in the top left / console.
        - color	color	The message's color (white by default).
        - prefix	string	The message's prefix (empty by default).
        - visible	boolean	If defined as true (default) the message will show in the top left otherwise it will only appear in the console.
    ]]--
    load_script = client.load_script,
    --[[ 
        -file_name	string	The file to load by name (example: "some.lua")
    ]]--
    choked_commands = client.choked_commands,
    --[[ 
        - returns amount of currently choked commands.
        - client.choked_commands(): number (integer).
    ]]--
    is_alive = client.is_alive,
    --[[ 
        - returns whether the localplayer is alive or not.
        - client.is_alive(): boolean.
    ]]--
    latency = client.latency,
    --[[ 
        - returns latency (rtt) to server
        - client.latency(): string
    ]]--
    local_time = client.local_time,
    --[[ 
        - client.local_time(format: string): string
        - format	string	time formatting
        - client.local_time("%r") -- will get you localized time string (including seconds)
        - client.local_time("%I:%M:%S") -- will get you HH:MM:SS time string (12-hour-format)
        - client.local_time("%H:%M:%S") -- will get you HH:MM:SS time string (24-hour-format)
    ]]
    unix_timestamp = client.unix_timestamp,
    --[[ 
        - returns unix timestamp
        - client.unix_timestamp(): number (integer) 
    ]]
    map_name = client.map_name,
    --[[ 
        - returns map name if ingame
        - client.map_name(): string
    ]]
    camera_position = client.camera_position,
    --[[ 
        - returns position of camera
        - client.camera_position(): vector
    ]]
    camera_angles = client.camera_angles, --[[ 
        - [x = -89 (up), 89 (down) | y = -179.9, 179.9 | z = 0 ]
        - returns camera angles
        - client.camera_angles(): qangle
    ]]
    find_sig = client.find_sig,
    --[[ 
        - returns address as integer or 0 when pattern (IDA-Style) was not found
        - client.find_sig(module: string, sig: string): number (integer)
        - Argument	   Type	       Description
        -  module	 string   	 e.g "client.dll"
        -   sig	    string    e.g "A3 ? ? ? ? 57 8B CB"
    ]]
    create_interface = client.create_interface,
    --[[ 
        - returns an address to the interface or 0 when not found
        - client.create_interface(module: string, interface: string): number (integer)
        - module	string	e.g "client.dll"
        - interface	string	e.g "VClient018" (has to be interface name (e.g. "VClient") including exact version (e.g. "018"))
    ]]
    username = client.username,
    --[[ 
        - global variable for the current user's name (displayed in watermark)
        - client.username 
    ]]
    -- eye_position = client.eye_position, not found
}

local anti_aim = {
    inverted = anti_aim.inverted,
    --[[ 
        - returns true when inverted or false when not
        - anti_aim.inverted(): boolean
    ]]
    should_run = anti_aim.should_run
    --[[ 
        - returns true when cheat should anti-aim on the command or false when not
        - anti_aim.should_run(cmd: usercmd, skip_firing_check: boolean): boolean
        - cmd	usercmd	-
        - skip_firing_check	boolean	when defined as true, the function will not account for firing (you ideally don't want to modify viewangles when firing)
    ]]
}

local engine_trace = {
    trace_ray = engine_trace.trace_ray,
    --[[ 
        - returns a game_trace object
        - engine_trace.trace_ray(start: vector, end: vector, skip : entity, mask: number): game_trace
        - start	vector	trace starting position
        - end	vector	trace ending position
        - skip	entity	entity to be skipped (filter)
        - mask	number (integer)	trace mask
        game_trace
Members
.allsolid
game_trace.allsolid

.endpos
game_trace.endpos: vector

.fraction
game_trace.fraction

.hitbox
game_trace.hitbox

.hitgroup
game_trace.hitgroup

.startsolid
game_trace.startsolid
    ]]
}

local entity = {
    hitbox_position = hitbox_position,
    get_prop = get_prop,
    eye_position = eye_position,
    origin = origin
}

local entity_list = {
    get_client_entity = entity_list.get_client_entity,
    --[[ 
        - returns an entity object
        - entity_list.get_client_entity(entnum: number OR netvar): entity
        - entnum	number (integer) OR netvar (handle by an existing entity)	reference to the entity.
    ]]
    get_all = entity_list.get_all,
    --[[ 
        - returns a table of all indices (valid entities) of the given entity/network name
        - entity_list.get_all(networkname: string): table (number -> entindex).
        - networkname	string	network name of the entity.
    ]]
    get_highest_entity_index = entity_list.get_highest_entity_index
    --[[ 
        - returns the index of the entity with the highest index
        - entity_list.get_highest_entity_index(): number
    ]]
}

local engine = {
    get_player_for_user_id = engine.get_player_for_user_id,
    --[[ 
        - returns an entity index (used for converting userid's of game events to entity indices)
        - engine.get_player_for_user_id(userid: number): number (integer)
        - userid	number (integer)	user id
    ]]
    in_game = engine.in_game,
    --[[ 
        - returns true if you are in a game or false if not
        - engine.in_game(): boolean
    ]]
    is_connected = engine.is_connected,
    --[[ 
        - returns true if you are connected to a server or false if notâ€Œ
        - engine.is_connected(): boolean
    ]]
    execute_client_cmd = engine.execute_client_cmd,
    --[[ 
        - executes a console command
        - engine.execute_client_cmd(cmd: string)
        - cmd	string	the commands name
    ]]
    set_view_angles = engine.set_view_angles,
    --[[ 
        - sets the engine view angles
        - engine.set_view_angles(viewangle: qangle)
        - viewangle	qangle	the viewangles to be set
    ]]
    get_view_angles = engine.get_view_angles,
    --[[ 
        - returns the engine view angles as a qangle object
        - engine.get_view_angles(): qangle
    ]]
    get_local_player = engine.get_local_player,
    --[[ 
        - returns the entity index of the local player
        - engine.get_local_player(): number
    ]]
    get_player_info = engine.get_player_info
    --[[ 
        - returns a player_info object
        - engine.get_player_info(entnum: number): player_info
        - entnum	number (integer)	an entity's index
    ]]
}

local esp = {
    set_thirdperson_animation = esp.set_thirdperson_animation,
    --[[ 
        - enable / disable thirdperson animation
        - esp.set_thirdperson_animation(value: boolean)
        - value	boolean	state (true by default)
    ]]
    set_fading_chams = esp.set_fading_chams,
    --[[ 
        - enable / disable chams animation
        - esp.set_fading_chams(value: boolean)
        - value	boolean	state (true by default)
    ]]
    add_player_flag = esp.add_player_flag
    --[[ 
        - adds a flag to the esp (right side of the box) NOTE: should be called inside paint callback
        - esp.add_player_flag(flag: string, color: color, entindex: number)
        - flag	string	the text to display
        - color	color	color of the text
        - entindex	number (integer)	the index of the player this flag should be displayed on
    ]]
}

local penetration = {
    damage =  penetration.damage,
    --[[ 
        - returns penetration damage of first penetrated wall
        - penetration.damage(): number (integer)
    ]]
    simulate_bullet = penetration.simulate_bullet
    --[[ 
        - simulates a bullet and returns damage, penetration count (amount of penetrations), hitgroup (the hitgroup that was hit)
        - penetration.simulate_bullet(attacker: entity, start: vector, end: vector): number (integer), number (integer), number (integer)
        - attacker	entity	the desired attacker (the data will be based on this entity)
        - start	vector	starting position
        - end	vector	ending position
    ]]
}

local material = {
    create_material = function() return material.create_material end,
    --[[ 
        - returns a material, make sure to check whether it is valid
        - materials.create_material(name: string, vmt: string, type: string): material
        - name	string	the materials name (can be found using materials.find_material)
    ]]
    find_material = function() return material.find_material end,
    --[[ 
        - returns a material, make sure to check whether it is valid
        - materials.find_material(name: string, group: string): material
        - name	string	the materials name
        - group	string	!OPTIONAL! the materials texture group
    ]]
}

local commands = {
    in_attack = function() return commands.in_attack end, -- attack
    in_jump = function() return command.in_jump end, -- jump
    in_duck = function() return command.in_duck end, -- duck
    in_forward = function() return command.in_forward end, -- forward
    in_back = function() return command.in_back end, -- back
    in_use = function() return command.in_use end, -- use
    in_cancel = function() return command.in_cancel end, -- cancel
    in_left = function() return command.in_left end, -- left
    in_right = function() return command.in_right end, -- right
    in_moveleft = function() return command.in_moveleft end, -- move moveleft
    in_moveright = function() return command.in_moveleft end, -- move moveright
    in_attack2 = function() return command.in_attack2 end, -- attack2
    in_reload = function() return command.in_reload end, -- reload
    in_speed = function() return command.in_speed end, -- speed
    in_bullrush = function() return command.in_bullrush end -- bull bullrush
}

local input = {
    key_down = input.key_down,
    --[[ 
        - returns true if the key is currently being held or false if not
        - input.key_down(key: number): boolean
        - key	number (integer)	virtual key code
    ]]
    key_pressed = input.key_pressed,
    --[[ 
        - returns true if the key was pressed (key was pressed and is still being held down) or false if not
        - input.key_pressed(key: number): boolean
        - key	number (integer)	virtual key code
    ]]
    mouse_position = input.mouse_position,
    --[[ 
        - returns x and y coordinate of mouse position
        - input.mouse_position(): number, number
    ]]
    force_cursor = input.force_cursor
    --[[ 
        - force enable / disable cursor(and input)
        - input.force_cursor(state: boolean)
        - state	boolean	enabled/disabled (true/false)
    ]]
}

local exploits = {
    process_ticks = exploits.process_ticks,
    --[[ 
        - returns current amount of process ticks
        - exploits.process_ticks(): number (integer)
    ]]
    max_process_ticks = exploits.max_process_ticks,
    --[[ 
        - returns maximum amount of process ticks
        - exploits.max_process_ticks(): number (integer)
    ]]
    charging = exploits.charging,
    --[[ 
        - returns true if you are currently charging process ticks
        - exploits.charging(): boolean
    ]]
    ready = function() return exploit.ready end,
    --[[ 
        - returns true if exploits are ready
        - exploits.ready(): boolean
    ]]
    force_recharge = exploits.force_recharge,
    --[[ 
        - forces exploits to be recharged
        - exploits.force_recharge() 
    ]]
}

local ui = {
    is_open = ui.is_open,
    --[[ 
        - returns true if the ui is currently open or false when it is closed
        - ui.is_open(): boolean
    ]]
    get = ui.get,
    --[[ 
        - gets a reference to a menu item and returns specified item as object
        - supported tabs: Rage (Aimbot)
        - ui.get(tab: string, sub_tab: string, group: string, option: string, weapon_group: string): UI
    ]]
    get_rage = ui.get_rage,
    --[[ 
        - gets a reference to a menu item and returns specified item as object (for active weapon configuration)
        - NOTE: should be called inside a paint or post_move callback, as otherwise you will receive the object of the weapon configuration that was active at the time of loading the script
        - supported tabs:
        - Rage (Aimbot)
        - ui.get_rage(group: string, option: string): UI
    ]]
    add_checkbox = ui.add_checkbox,
    --[[ 
        - adds a Checkbox to the "Items" group box of the LUA tab (script specific) and returns a checkbox object
        - ui.add_checkbox(name: string): checkbox
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
    ]]
    add_dropdown = ui.add_dropdown,
    --[[ 
        - adds a Dropdown to the "Items" group box of the LUA tab (script specific) and returns a dropdown object
        - ui.add_dropdown(name: string, [items: string]): dropdown
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - items	string table	items (names)
    ]]
    add_multi_dropdown = ui.add_multi_dropdown,
    --[[ 
        - adds a Multi-dropdown to the "Items" group box of the LUA tab (script specific) and returns a multidropdown object
        - ui.add_multi_dropdown(name: string, [items: string]): multidropdown
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - items	string table	items (names)
    ]]
    add_button = ui.add_button,
    --[[ 
        - adds a button to the "Items" group box of the LUA tab (script specific) and returns a button object
        - ui.add_button(text: string): button
        - text	string	displayed text
        [Example]
        local button = ui.add_button("My epic button")
        button:add_callback(function()
            print("test!") -- will print text to the game's console
        end)
    ]]
    add_textbox = ui.add_textbox,
    --[[ 
        - adds a textbox to the "Items" group box of the LUA tab (script specific) and returns a textbox object
        - ui.add_textbox(name: string): textbox
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        -returns the textbox input vale as a string
        -textbox_object:get(): string
    ]]
    add_label = ui.add_label,
    --[[ 
        - adds a label (text) to the "Items" group box of the LUA tab (script specific)
        - ui.add_label(text: string)
        - text	string	displayed text
    ]]
    add_cog = ui.add_cog,
    --[[ 
        - set_key_cond |0 = hold | 1 = toggle | 2 = always|
        - adds a Cog (without label, ..) to the "Items" group box of the LUA tab (script specific) and returns a cog object
        - ui.add_cog(tooltip: string, color: boolean, hotkey: boolean): cog
        - tooltip	string	Tooltip (this should be unique in-script as it is used for the configuration system -> avoid adding 2 or more items with the same Tooltip)
        - color	boolean	when true, a colorpicker will be added
        - hotkey	boolean	when true, a hotkey will be added
        [example]
        -- you have to add a label, checkbox, .... before the cog
        -- as the cog is relative to previous items and may not show otherwise.
        ui.add_label("My epic cog") -- this does not return anything
        local cog_item = ui.cog("My Epic Tooltip", true, true)
    ]]
    add_slider = ui.add_slider,
    --[[ 
        - adds a Slider to the "Items" group box of the LUA tab (script specific) and returns a slider object
        - ui.add_slider(name: string, min: number, max: number): slider
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - min	number (integer)	minimum value of the slider
        - max	number (integer)	maximum value of the slider
        [example]
        local slider_item = ui.add_slider("My epic slider", 0, 1337)
    ]]
    add_slider_float = ui.add_slider_float,
    --[[ 
        - adds a Slider to the "Items" group box of the LUA tab (script specific) and returns a slider object
        - ui.add_slider_float(name: string, min: number, max: number): slider
        - name	string	item display name (this should be unique in-script -> avoid adding 2 or more items with the same name)
        - min	number (float)	minimum value of the slider
        - max	number (float)	maximum value of the slider
        [example]
        local slider_item = ui.add_slider_float("My epic slider", 0.1, 69.69)
    ]]
}

local cvar = {
    find_var = cvar.find_var
    --[[ 
        - returns a convar object
        - cvar.find_var(var_name: string): convar
        - var_name	string	console command's name
    ]]
}

local render = {
    rectangle = render.rectangle,
    --[[ 
        - draws a rectangle
        - render.rectangle(x: number, y: number, w: number, h: number, color: color)
        - x	number (integer)	x coordinate
        - y	number (integer)	y coordinate
        - w	number (integer)	render width
        - h	number (integer)	render height
        - color	color	color the drawing renders with
    ]]
    rectangle_filled = render.rectangle_filled,
    --[[ 
        - draws a filled rectangle
        - render.rectangle_filled(x: number, y: number, w: number, h: number, color: color)
    ]]
    gradient = render.gradient,
    --[[ 
        - draws a filled fade rectangle
        - render.gradient(x: number, y: number, w: number, h: number, color: color, color2: color, horizontal: boolean)
        - [Extra]
        - color	color	color of the first half the drawing renders with
        - color2	color	color of the second half the drawing renders with
        - horizontal	boolean	fading direction (vertical by default)
    ]]
    triangle_filled = render.triangle_filled,
    --[[ 
        - render.triangle_filled(pos1: vector2d, pos2: vector2d, pos3: vector2d, color: color)
        - pos1	vector2d	coordinate of first corner
        - pos2	vector2d	coordinate of second corner
        - pos3	vector2d	coordinate of third corner
        - color	color	color the drawing renders with
    ]]
    circle_world = render.circle_world,
    --[[ 
        - draws a (filled) circle in world space (no world to screen required)
        - render.circle_world(origin: vector, radius: number, color: color, colorFill: color)
        - origin	vector	the circles origin/position in world space
        - radius	number (float)	the circles radius
        - color	color	color the drawing renders with (outer circle, "outline")
        - colorFill	color	color the drawing renders with (inner circle, "filling")
    ]]
    circle_filled = render.circle_filled,
    --[[ 
        - draws a filled circle
        - render.circle_filled(x: number, y: number, radius: number, segments: number, color: color)
        - x	number (integer)	x coordinate
        - y	number (integer)	y coordinate
        - radius	number (float)	circle radius
        - segments	number (integer)	circle segments
        - color	color	color the drawing renders with
    ]]
    line = render.line,
    --[[ 
        - draws a line
        - render.line(x: number, y: number, x2: number, y2: number, color: color)
        - x	number (integer)	(from) x coordinate
        - y	number (integer)	(from) y coordinate
        - x2	number (integer)	(to) x coordinate
        - y2	number (integer)	(to) y coordinate
        - color	color	color the drawing renders with
    ]]
    text = render.text,
    --[[ 
        draws a text
        render.text(x: number, y: number, text: string, color: color)
        x	number (integer)	x coordinate
        y	number (integer)	y coordinate
        text	string	text to draw
        color	color	color the drawing renders with
    ]]
    get_text_size = render.get_text_size,
    --[[ 
        - returns width and height of the text given (font used in render.text)
        - render.get_text_size(text: string): number, number
        - text	string	text you want to get the width/height of
    ]]
    create_font = render.create_font,
    --[[ 
        - returns a Font object (avoid calling this in a callback function, setup before doing anything)
        - render.create_font(fontname: string, size: number, weight: number, flags: font_flags): Font
        - fontname	string	font name (Arial, ...)
        - size	number (integer)	font size in pixels
        - weight	number (integer)	font weight
        - flags	font_flags	font flags
    ]]
    get_screen = render.get_screen,
    --[[ 
        - returns the width and height of the screen
        - render.get_screen(): number, numbe
    ]]
    world_to_screen = render.world_to_screen
    --[[ 
        - transforms the coordinates from world space to screen and returns true when successfully transformed or false when not
        - render.world_to_screen(input: vector, output: vector2d): boolean
        - input	vector	-
        - output	vector2d	output (screen coordinates)
    ]]
}

local font_flags = {
    font_flags = font_flags.none,
    --[[ 
        - no font flag
    ]]
    antialias = font_flags.antialias,
    --[[ 
        - adds anti-aliasing to the font
    ]]
    dropshadow = font_flags.dropshadow,
    --[[ 
        - adds a dropshadow to the font
    ]]
    outline = font_flags.outline,
    --[[ 
        - adds an outline to the font
    ]]
    --[[ 
        [Example]
        -- multiple flags example
        local arial_drop_outline = render.create_font("Arial", 12, 500, bit.bor(font_flags.dropshadow, font_flags.outline))
        -- single flag example
        local arial_drop = render.create_font("Arial", 12, 500, font_flags.dropshadow)
    ]]
}

local callbacks = {
    register = callbacks.register,
    deregister = callbacks.deregister
    --[[ 
        [paint]
        - used for drawing (or calling something) every frame (using the render functions).
        function on_paint()
            -- cool, useless, rectangle!
            render.rectangle(10, 10, 10, 10, color.new(255, 255, 255))
        end
        callbacks.register("paint", on_paint)

        [pre_frame_stage]
        - called right before FrameStageNotify and internal functions when localplayer is valid.
        function on_frame_stage(stage) -- stage: current frame stage
            
        end
        callbacks.register("pre_frame_stage", on_frame_stage)

        [post_frame_stage]
        - called right after FrameStageNotify and internal functions when localplayer is valid.
        function on_frame_stage(stage) -- stage: current frame stage

        end
        callbacks.register("post_frame_stage", on_frame_stage)
    
        [post_move]
        - used to modify the user command after the internal modifications using "usercmd".
        function on_post_move(cmd) -- the first argument is the command's "pointer"
            -- let's see if we want to anti aim
            if anti_aim.should_run(cmd, false) == false then    
                return
            end
        
            -- up pitch (gamer moment)
            cmd.viewangles.x = -89
        end

        callbacks.register("post_move", on_post_move)

        [predicted_move]
        - used to modify the user command inside prediction, after move related features have ran, using usercmd.
        function on_predicted_move(cmd) -- the first argument is the command's "pointer"
            -- do something
        end

        callbacks.register("predicted_move", on_predicted_move)

        [post_anim_update]
        - can be used to modify animation / bones related data of the local player.
        - set_float_index is undocumented, however it can be used to modify float arrays (like m_flPoseParameter)
        -- there also is get_float_index(index: number(integer)): number (float)
        -- "falling legs" example:
        callbacks.register("post_anim_update", function(ent)
            local m_flPoseParameter = ent:get_prop("DT_BaseAnimating", "m_flPoseParameter");
            m_flPoseParameter:set_float_index(6, 1); -- first argument is the index, second the value to be set to
        end)

        [on_hitmarker]
        - used to get the damage and position of where the localplayer hit.
        function on_hitmarker(damage, position) -- damage: number (float), position: vector

        end

        callbacks.register("on_hitmarker", on_hitmarker)

        [draw_model]
        - used to draw models using model_draw_context.
        -- grab a material (or create one)

        local flat_mat = materials.find_material("debug/debugdrawflat")
        -- let's see, if the material is valid
        local flat_mat_valid = flat_mat:is_valid()
        function on_draw_model(context) -- the first argument is the entity's model_draw_context
            -- let's see if the current entity is the localplayer
           if context:get_entity():index() == engine.get_local_player() then
                if flat_mat_valid then
                    -- r, g, b (0.0-1.0)
                    flat_mat:modulate_color(1, 1, 1)
                
                    -- a (0.0-1.0)
                    flat_mat:modulate_alpha(0.5)
                
                    -- set flag (ignorez)
                    flat_mat:set_material_var_flag((1 << 15), true) -- ignorez
                
                    -- draw the entity with our material
                    context:force_material_override(flat_mat)
                end
           end
        end

        callbacks.register("draw_model", on_draw_model)
    ]]
}

local vector = {
    new = vector.new
    --[[ 
        new (constructor)
        - vector.new(x: number, y: number, z: number)
        - 
        - Argument	Type	Description
        - x	number (float)	x value
        - y	number (float)	y value
        - z	number (float)	z value
    ]]
}

local vertex = {
    vertex = vertex.new,
    --[[ 
        - [Objet]
            vector2d	position
            vector2d	texCoord

        - vertex.new(position: vector2d, texCoord: vector2d)
        - Argument	Type	Description
        - position	vector2d	position
        - texCoord	vector2d	texture coordinate
        - local some_vertex = vertex.new(vector2d.new(69, 420), vector2d.new(1337, 0))
    ]]
}

local vector2d = {
    new = vector2d.new
}

local Qangle = {}
Qangle.__index = qangle.new

local color = {
    new = color.new
}

local bit = {
    band = bit.band,
    lshift = bit.lshift,
    bor = bit.bor
}

local urls = {
    fonts = "https://github.com/HeistOmega/DiaApi/raw/45c709dfce8fa8aa44d8cc27aa65541b86535023/fonts",
    sounds = "https://github.com/HeistOmega/DiaApi/raw/50293b198188bfcf7178ccb60b9c18524ef1ff47/Sounds",
    destination = {
        fonts = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\Diabolik\\fonts\\",
        sounds = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\Diabolik\\Sounds\\"
    }
}

local global_vars = {
    curtime = function() return global_vars.curtime end,
    --[[ 
        - global variable for the engines current time
        - global_vars.curtime: number (float)
    ]]
    frametime = function() return global_vars.frametime end,
    --[[ 
        - global variable for the engines frame time
        - global_vars.frametime: number (float)
    ]]
    absoluteframetime = function() return global_vars.absoluteframetime end,
    --[[ 
        - global variable for the engines absolute frame time
        - global_vars.absoluteframetime: number (float)
    ]]
    framecount = function() return global_vars.framecount end,
    --[[ 
        - global variable for the engines frame count
        - global_vars.framecount: number (integer) 
    ]]
    tickcount = function() return global_vars.tickcount end,
    --[[ 
        - global_vars.tickcount
        - global variable for the engines tick count
        - global_vars.tickcount: number (integer)
    ]]
    realtime = function() return global_vars.realtime end,
    --[[ 
        - global variable for the engines real time
        - global_vars.realtime: number (float)
    ]]
    max_clients = function() return global_vars.max_clients end,
    --[[ 
        - global variable for the engines max clients
        - global_vars.max_clients: number (integer)
    ]]
    interval_per_tick = function() return global_vars.interval_per_tick end
    --[[ 
        - global variable for the engines interval per tick
        - global_vars.interval_per_tick: number (integer)
    ]]
}

--[[ Update Important netvars ]]
local update_global_vars = function()
    global_vars.tickcount = global_vars.tickcount
    global_vars.curtime = global_vars.curtime
    global_vars.frametime = global_vars.frametime
    material.create_material = material.create_material
end

callbacks.register("paint", function()
    update_global_vars()
end)

--[[ Paths ]]
local base_path = "C:\\Program Files (x86)\\Steam\\steamapps\\common\\Counter-Strike Global Offensive\\Pandora\\"

--[[ FFI ]]
local ffi = require("ffi")
local urlmon = ffi.load('urlmon')
local kernel32 = ffi.load('kernel32')

ffi.cdef[[
    typedef int HRESULT;
    HRESULT URLDownloadToFileA(void* pCaller, const char* szURL, const char* szFileName, unsigned long dwReserved, void* lpfnCB);
    bool CreateDirectoryA(const char* lpPathName, void* lpSecurityAttributes);
]]

Create_directory = function(path)
    local result = kernel32.CreateDirectoryA(base_path .. path, nil)
    if result == 0 then
        local error_code = ffi.C.GetLastError()
        if error_code ~= 183 then  -- 183 significa que el directorio ya existe
            print("Error al crear el directorio. Codigo de error: " .. error_code)
            return false
        end
    end
    print("Directorio creado: \n" .. base_path .. path)
    return true
end

Download_file = function(url, destination)
    local result = urlmon.URLDownloadToFileA(nil, url, destination, 0, nil)
    if result == 0 then
        print("Descarga exitosa: \n" .. destination)
    else
        print("Error en la descarga. Codigo de error: " .. result)
    end
end

Download_files = function(file_list, base_url, base_destination)
    for _, file_name in ipairs(file_list) do
        local url = base_url .. "/" .. file_name
        local destination = base_destination .. file_name
        Download_file(url, destination)
    end
end

Length3D = function(x, y, z)
    assert(type(x) == "number" and type(y) == "number" and type(z) == "number", "Invalid input Length3D") -- https://www-lua-org.translate.goog/pil/8.3.html?_x_tr_sl=en&_x_tr_tl=es&_x_tr_hl=es&_x_tr_pto=tc
    return math.sqrt((x^2)+(y^2 )+(z^2))
end

Atan2 = function(y, x)
    if x > 0 then
        return math.atan(y / x)
    elseif x < 0 then
        if y == 0 then
            return math.pi
        elseif y > 0 then
            return math.atan(y / x) + math.pi
        else -- y < 0
            return math.atan(y / x) - math.pi
        end
    elseif x == 0 then
        if y > 0 then
            return math.pi / 2
        elseif y < 0 then
            return -math.pi / 2
        else -- y == 0
            return nil
        end
    end
end

Cross = function(u, v) -- Producto cruzado
    assert(#u >= 3 and #v >= 3, "Los vectores deben tener al menos 3 elementos")
    return {
        u[2] * v[3] - u[3] * v[2],
        u[3] * v[1] - u[1] * v[3],
        u[1] * v[2] - u[2] * v[1]
    }
end

Angle_diff = function(dest, src)
    local delta = 0
    delta = math.fmod(dest - src, 360)
    if (dest > src) then
        if (delta >= 180) then
            delta = delta - 360
        end
    elseif (delta <= -180) then
        delta = delta + 360
    end
    return delta
end

Clamp = function(val, min, max)
    if type(val) ~= "number" or type(min) ~= "number" or type(max) ~= "number" then
        error("error Dia_API [Clamp fn]")
    end
    if min > max then
        min, max = max, min
    end
    if val == nil then return min end
    return math.max(min, math.min(max, val))
end

Clamp_yaw = function(yaw)
	while yaw < -180.0 do yaw = yaw + 360.0 end
	while yaw > 180.0 do yaw = yaw - 360.0 end
	return yaw
end

Length_sqr = function(vec)
    return (vec.x * vec.x) + (vec.y * vec.y) + (vec.z * vec.z)
end

Normalized = function(v) -- Normaliza un vector
    assert(#v >= 3, "El vector debe tener al menos 3 elementos")
    local magnitude = math.sqrt(v[1]^2 + v[2]^2 + v[3]^2)
    if magnitude == 0 then
        return {0, 0, 0}
    end
    return {
        v[1] / magnitude,
        v[2] / magnitude,
        v[3] / magnitude
    }
end

CalcAngle = function(local_origin, target_origin)
    local delta = {
        x = target_origin.x - local_origin.x,
        y = target_origin.y - local_origin.y,
        z = target_origin.z - local_origin.z
    }
    local hyp = math.sqrt(delta.x * delta.x + delta.y * delta.y)
    local yaw = Atan2(delta.y, delta.x) * (180 / math.pi)
    return yaw
end

Initialize_animation_info = function()
    return {
        m_flResolveAngle = 0,
        m_flLastResolveAngle = 0,
        m_flAngleBeforeResolve = 0,
        m_flAngleAfterResolve = 0,
        m_flResolveDelta = 0,
        iResolveIndex = 0,
        m_flPreviousAngleDifference = 0,
        m_flVelocity = 0,
        m_flWalkToRunTransition = 0,
        m_bWalkToRunTransitionState = false
    }
end

Angle_to_forward_vector = function(pitch, yaw, roll)
    local sy = math.sin(math.rad(yaw))
    local cy = math.cos(math.rad(yaw))
    local sp = math.sin(math.rad(pitch))
    local cp = math.cos(math.rad(pitch))
    return {cp * cy, cp * sy, -sp}
end

Get_backward_side = function(player)
    local local_player = entity_list.get_client_entity(engine.get_local_player())
    if not player or not local_player then return 0 end
    local a = Get_vector(local_player)
    local b = Get_vector(player)
    if not a or not b or not a.x or not a.y or not a.z or not b.x or not b.y or not b.z then
        return 0
    end
    return CalcAngle(a, b)
end

Anglemod = function(angle) -- Normalizar angulo entre 0 y 360
    return (angle % 360 + 360) % 360
end

ApproachAngle = function(target, value, speed) -- Aproximar un angulo hacia el objetivo
    target = Anglemod(target)
    value = Anglemod(value)
    local delta = target - value
    speed = math.abs(speed)

    if delta < -180.0 then -- Ajustar delta para manejar la envoltura circular
        delta = delta + 360.0
    elseif delta > 180.0 then
        delta = delta - 360.0
    end

    if delta > speed then
        value = value + speed
    elseif delta < -speed then
        value = value - speed
    else
        value = target
    end

    return value
end

-- Ajusta el yaw del jugador si esta cerca de una pared (freestand)
Calculate_adjusted_yaw = function(player_position, player_view_direction, current_yaw, current_pitch)
    local max_simulation_distance = 100
    local attacker = engine.get_local_player()
    local damage, penetration_count = penetration.simulate_bullet(
        attacker, -- Jugador atacante
        player_position, -- PosiciÃ³n inicial
        player_position + player_view_direction * max_simulation_distance -- PosiciÃ³n final
    )
    if penetration_count > 0 and math.abs(current_pitch + 90) < 5 then
        return 90
    end
    return current_yaw
end

TraceWithDistance = function(start_pos, end_pos, player, trace_filter)
    local trace = engine_trace.trace_ray(start_pos, end_pos, player, trace_filter)
    return trace, (trace.end_pos - trace.start_pos):length()
end

CalculatePredictedWalkToRunTransition = function(m_flWalkToRunTransition, m_bWalkToRunTransitionState, m_flLastUpdateIncrement, m_flVelocityLengthXY)
    ANIM_TRANSITION_WALK_TO_RUN = false
    ANIM_TRANSITION_RUN_TO_WALK = true
    CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED = 2
    PLAYER_RUN_SPEED = 260
    CS_PLAYER_SPEED_WALK_MODIFIER = 0.52
    local transition_speed_threshold = PLAYER_RUN_SPEED * CS_PLAYER_SPEED_WALK_MODIFIER
    if m_flWalkToRunTransition > 0 and m_flWalkToRunTransition < 1 then
        local increment = m_flLastUpdateIncrement * CSGO_ANIM_WALK_TO_RUN_TRANSITION_SPEED
        if m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN then
            m_flWalkToRunTransition = m_flWalkToRunTransition + increment
        else
            m_flWalkToRunTransition = m_flWalkToRunTransition - increment
        end
        m_flWalkToRunTransition = Clamp(m_flWalkToRunTransition, 0, 1)
    end
    if m_flVelocityLengthXY > transition_speed_threshold then
        if m_bWalkToRunTransitionState == ANIM_TRANSITION_RUN_TO_WALK then
            m_bWalkToRunTransitionState = ANIM_TRANSITION_WALK_TO_RUN
            m_flWalkToRunTransition = math.max(0.01, m_flWalkToRunTransition)
        end
    elseif m_flVelocityLengthXY < transition_speed_threshold then
        if m_bWalkToRunTransitionState == ANIM_TRANSITION_WALK_TO_RUN then
            m_bWalkToRunTransitionState = ANIM_TRANSITION_RUN_TO_WALK
            m_flWalkToRunTransition = math.min(0.99, m_flWalkToRunTransition)
        end
    end
    return m_flWalkToRunTransition, m_bWalkToRunTransitionState
end

CalculatePredictedFootYaw = function(m_flFootYawLast, m_flEyeYaw, m_flLowerBodyYawTarget, m_flWalkToRunTransition, m_vecVelocity, m_flMinBodyYaw, m_flMaxBodyYaw)
    local m_flVelocityLengthXY = math.min(Length_sqr(m_vecVelocity), 320) -- calcula la longitud del vector de velocidad en el plano XY, limitada a [value]
    local m_flFootYaw = Clamp(m_flFootYawLast, -360, 360) -- limita m_flFootYawLast al rango [-360, 360]
    local flEyeFootDelta = Angle_diff(m_flEyeYaw, m_flFootYaw) -- calcula la diferencia angular entre la orientacion de los ojos y la orientacion del pie

    if flEyeFootDelta > m_flMaxBodyYaw then -- ajusta m_flFootYaw si la diferencia excede los limites permitidos
        m_flFootYaw = m_flEyeYaw - math.abs(m_flMaxBodyYaw)
    elseif flEyeFootDelta < m_flMinBodyYaw then
        m_flFootYaw = m_flEyeYaw + math.abs(m_flMinBodyYaw)
    end

    m_flFootYaw = Anglemod(m_flFootYaw) -- Normaliza m_flFootYaw al rango [0, 360)
    local m_flLastUpdateIncrement = global_vars.interval_per_tick() -- obtiene el incremento de tiempo desde la Ãºltima actualizacion de los ticks del sv
    if ((m_flVelocityLengthXY > 0.1) or (m_vecVelocity.z > 100)) then -- si el personaje se esta moviendo o tiene una velocidad vertical significativ
        local transition_speed = 30 + (20 * m_flWalkToRunTransition) -- calcula la velocidad de transiciÃ³n basada en m_flWalkToRunTransition
        m_flFootYaw = ApproachAngle(m_flEyeYaw, m_flFootYaw, m_flLastUpdateIncrement * transition_speed) -- ajusta m_flFootYaw acercandolo a m_flEyeYaw
    else
        m_flFootYaw = ApproachAngle(m_flLowerBodyYawTarget, m_flFootYaw, m_flLastUpdateIncrement * 100) -- Si el personaje esta casi detenido, ajusta m_flFootYaw hacia m_flLowerBodyYawTarget
    end
    return m_flFootYaw -- retorna m_flFootYaw
end

UpdateEnemyList = function() -- return enemy list
    local local_player = entity_list.get_client_entity(engine.get_local_player())
    local AllPlayers = entity_list.get_all("CCSPlayer")
    if not local_player or #AllPlayers < 1 then return {} end
    local Enemy_list = {}
    for i = 1, #AllPlayers do
        local entity_filtered = entity_list.get_client_entity(AllPlayers[i])
        local entity_team, local_team = Get_team(entity_filtered), Get_team(local_player)
        if entity_filtered ~= local_player and entity_team ~= local_team and Is_alive(entity_filtered) == true then
            table.insert(Enemy_list, entity_filtered)
        end
    end
    return Enemy_list
end

Verify_vector_components = function(parametro) -- verificacion de vector i/o valores nulos y retorno de distancia
    if type(parametro) ~= "table" then return false end -- verifica si el parametro es una tabla
    if not parametro.x or not parametro.y or not parametro.z then return false end -- verifica si los valores existen
    if type(parametro.x) ~= "number" or type(parametro.y) ~= "number" or type(parametro.z) ~= "number" then return false end -- verifica si los valores son del tipo numerico
    return true
end

-- Obtener posiciones de las flechas segÃºn el estado de inversiÃ³n
Draw_arrow = function(ind_pos, is_inverted, color_active, color_inactive, font)
    local left_pos = ind_pos.x - 50
    local right_pos = ind_pos.x + 30
    local y_pos = ind_pos.y - 11

    -- Determinar colores segÃºn la inversiÃ³n
    local left_color = is_inverted and color_inactive or color_active
    local right_color = is_inverted and color_active or color_inactive

    -- Dibujar las flechas
    font:text(left_pos, y_pos, left_color, " â—„ ")
    font:text(right_pos, y_pos, right_color, " â–º ")
end

Dist_3d = function(player_position, enemy_position) -- verificacion de vectores i/o valores nulos y retorno de distancia entre estos
    if not Verify_vector_components(player_position) then print("Invalid player position") end
    if not Verify_vector_components(enemy_position) then print("Invalid enemy position") end
    local dx = player_position.x - enemy_position.x
    local dy = player_position.y - enemy_position.y
    local dz = player_position.z - enemy_position.z
    return Length3D(dx, dy, dz)
end

Get_vector = function(entity) -- get (x,y,z) positions of entity
    local entity = entity:get_prop("DT_BaseEntity", "m_vecOrigin"):get_vector()
    return entity
end

Get_team = function(entity) -- get team of entity returns a int value 
    local ent_team = entity:get_prop("DT_BaseEntity", "m_iTeamNum"):get_int()
    return ent_team
end

Get_health = function(entity) -- get health of entity
    local health = entity:get_prop("DT_BasePlayer", "m_iHealth"):get_int()
    return health
end

Get_shoot_position = function(player) -- obtiene la position del enemigo cuando dispara, usar con el callback [on_shot_fired]
    local p_vec = Get_vector(player) -- Vector (x, y, z)
    return { p_vec.x, p_vec.y, p_vec.z }
end

Is_alive = function(entity) -- returns true if the entity is alive
    if entity then
        local health = Get_health(entity)
        if health <= 0 then
            return false
        end
        return true
    end
end

Is_scoped = function(entity) -- is entity es scoped return true
    if entity then
        local scoped = entity:get_prop("DT_CSPlayer", "m_bIsScoped"):get_bool()
        if scoped then
            return true
        end
    end
    return false
end

Get_fLBYT = function(entity)
    if entity then
        local body_yaw = entity:get_prop("DT_CSPlayer", "m_flLowerBodyYawTarget"):get_int()
        return body_yaw
    end
end

AngEye = function(entity)
    if entity then
        local x = entity:get_prop("DT_CSPlayer", "m_angEyeAngles[0]"):get_float()
        local y = entity:get_prop("DT_CSPlayer", "m_angEyeAngles[1]"):get_float()
        return {x, y}
    end
end

Get_prop_int = function(entity, table_name, prop_name)
    return entity:get_prop(table_name, prop_name):get_int()
end

Get_prop_float = function(entity, table_name, prop_name)
    return entity:get_prop(table_name, prop_name):get_float()
end

Get_velocity = function(entity) -- Calcular velocidad del jugador
    if not entity then return 0 end
    local x = Get_prop_float(entity, "DT_BasePlayer", "m_vecVelocity[0]")
    local y = Get_prop_float(entity, "DT_BasePlayer", "m_vecVelocity[1]")
    return math.floor(math.sqrt(x * x + y * y))
end

Is_crouching = function(entity) -- Verificar si el jugador esta agachado/duck
    if not entity then return false end
    local CROUCH_FLAG = 4
    local flags = Get_prop_int(entity, "DT_BasePlayer", "m_fFlags")
    return bit.band(flags, CROUCH_FLAG) ~= 0
end

Is_inair = function(entity) -- Verificar si el jugador esta en el aire
    if not entity then return false end
    return Get_prop_int(entity, "DT_BasePlayer", "m_hGroundEntity") == -1
end

Is_moving = function(entity) -- Verificar si el jugador esta moviendose
    if not entity then return false end
    local velocity = Get_velocity(entity)
    return velocity >= 8
end

Is_standing = function(entity) -- Verificar si el jugador esta quieto y no moviendose y tampoco en el aire
    return entity and not Is_moving(entity) and not Is_inair(entity)
end

Is_slow_walking = function(entity)
    if not entity then return false end
    return ui.get_rage("Misc", "General", "Movement", "Slow motion key"):get_key()
end

Is_fake_ducking = function(entity) -- Verificar si el jugador esta haciendo fakeduck
    if not entity then return false end
    local DUCK_SPEED_THRESHOLD = 8
    local duck_speed = Get_prop_float(entity, "DT_BasePlayer", "m_flDuckSpeed")
    local duck_amount = Get_prop_float(entity, "DT_BasePlayer", "m_flDuckAmount")
    return duck_speed == DUCK_SPEED_THRESHOLD and duck_amount > 0 and not Is_inair(entity)
end

return {
    client = client,
    anti_aim = anti_aim ,
    engine_trace = engine_trace,
    entity = entity,
    entity_list = entity_list,
    engine = engine,
    esp = esp,
    penetration = penetration,
    material = material,
    commands = commands,
    input = input,
    exploits = exploits,
    ui = ui,
    cvar = cvar,
    font_flags = font_flags,
    render = render,
    callbacks = callbacks,
    vector = vector,
    vector2d = vector2d,
    vertex = vertex,
    Qangle = Qangle,
    color = color,
    bit = bit,
    global_vars = global_vars,
    urls = urls,
    AngEye = AngEye,
    CalculatePredictedWalkToRunTransition = CalculatePredictedWalkToRunTransition,
    CalculatePredictedFootYaw = CalculatePredictedFootYaw,
    Clamp = Clamp,
    Atan2 = Atan2,
    Normalized = Normalized,
    Anglemod = Anglemod,
    ApproachAngle = ApproachAngle,
    CalcAngle = CalcAngle,
    Angle_diff = Angle_diff,
    ActualizarDatos = ActualizarDatos,
    Initialize_animation_info = Initialize_animation_info,
    Draw_arrow = Draw_arrow,
    Clamp_yaw = Clamp_yaw,
    Get_fLBYT = Get_fLBYT,
    Get_velocity = Get_velocity,
    Is_crouching = Is_crouching,
    Get_health = Get_health,
    Get_vector = Get_vector,
    Get_shoot_position = Get_shoot_position,
    TraceWithDistance = TraceWithDistance,
    Calculate_adjusted_yaw = Calculate_adjusted_yaw,
    Get_backward_side = Get_backward_side,
    Angle_to_forward_vector = Angle_to_forward_vector,
    Verify_vector_components = Verify_vector_components,
    UpdateEnemyList = UpdateEnemyList,
    Cross = Cross,
    Length3D = Length3D,
    Dist_3d = Dist_3d,
    Is_alive = Is_alive,
    Get_team = Get_team,
    Is_inair = Is_inair,
    Is_moving = Is_moving,
    Is_scoped = Is_scoped,
    Is_standing = Is_standing,
    Is_slow_walking = Is_slow_walking,
    Is_fake_ducking = Is_fake_ducking,
    Create_directory = Create_directory,
    Download_files = Download_files,
}
